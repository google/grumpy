#!/usr/bin/env python

# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""gentest creates a Golang module_test.go from a Python file, for coverage.

Usage: $ gentest -m <module>             # Create test from the named module.
"""

import argparse
import os
import sys
import textwrap

from grumpy.compiler import imputil

parser = argparse.ArgumentParser()
parser.add_argument('-modname', required=True,
                    help='Module to generate a _test.go file to')


template = textwrap.dedent("""
  package %s
  import (
  \t"testing"
  \t"grumpy"
  \t%s
  )
  func TestRunCode(t *testing.T) {
  \tgrumpy.ImportModule(grumpy.NewRootFrame(), "traceback")
  \tif grumpy.RunMain(Code) != 0 {
  \t\tt.Fail()
  \t}
  }
""")


def _package_name(modname):
  if modname.startswith('__go__/'):
    return '__python__/' + modname
  return '__python__/' + modname.replace('.', '/')


def _get_gopath():
  gopath = os.getenv('GOPATH', None)
  if not gopath:
    print >> sys.stderr, 'GOPATH not set'
    raise RuntimeError('GOPATH not set')
  return gopath


def main(args):
  modname = args.modname
  gopath = _get_gopath()
  workdir = 'build'   # It is ok _right now_
  py_dir = os.path.join(workdir, 'src', '__python__')
  mod_dir = os.path.join(py_dir, modname.replace('.', '/'))

  script = os.path.join(py_dir, '%s.py' % modname.replace('.', '/'))
  gopath = gopath + os.pathsep + workdir
  testfile_modname = modname[:-5] if modname.endswith('_test') else modname
  testfile_modname = testfile_modname.split('.')[-1]

  if not os.path.isfile(script):
    return  # The script does not exist. And is OK!

  names = imputil.calculate_transitive_deps(modname, script, gopath)

  # Find the script associated with the given module.
  for d in gopath.split(os.pathsep):
    script = imputil.find_script(os.path.join(d, 'src', '__python__'), modname)
    if script:
      break
  else:
    raise RuntimeError("can't find module %s", modname)

  names = imputil.calculate_transitive_deps(modname, script, gopath)
  # Make sure traceback is available in all Python binaries.
  names.add('traceback')

  imports = '\n\t'.join('_ "%s"' % _package_name(name) for name in names)

  testfile_contents = template % (testfile_modname, imports)
  with open(os.path.join(mod_dir, 'module_test.go'), 'w') as go_testfile:
    go_testfile.write(testfile_contents)


if __name__ == '__main__':
  sys.exit(main(parser.parse_args()))
